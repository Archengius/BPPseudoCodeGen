"use strict";
const fs = require("fs");
const path = require('path');

let JsonText = fs.readFileSync("FGBlueprints.json", "utf8");
console.log("Done reading file");
let ParsedJson = JSON.parse(JsonText.substring(1));
console.log("Done parsing json");

/**
 * @return {string}
 */
function GetBasicType(Category, SubCategoryObject, IsWeakPointer) {
  Category = Category.toLowerCase();
  if (Category === "interface") {
    return `TScriptInterface<${SubCategoryObject}>`;
  } else if (Category === "class") {
    return `TSubclassOf<${SubCategoryObject}>`;
  } else if (Category === "softclass") {
    return `TSoftClassPtr<${SubCategoryObject}>`;
  } else if (Category === "softobject") {
    return `TSoftObjectPtr<${SubCategoryObject}>`;
  } else if (Category === "object") {
    if (IsWeakPointer) {
      return `TWeakObjectPtr<${SubCategoryObject}>`;
    } else {
      return `${SubCategoryObject}*`;
    }
  } else if (Category === "struct") {
    return SubCategoryObject;
  } else if (Category === "float") {
    return "float";
  } else if (Category === "int64") {
    return "int64";
  } else if (Category === "int") {
    return "int32";
  } else if (Category === "byte") {
    return "uint8";
  } else if (Category === "name") {
    return "FName";
  } else if (Category === "bool") {
    return "bool";
  } else if (Category === "string") {
    return "FString";
  } else if (Category === "text") {
    return "FText";
  } else if (Category === "delegate") {
    return "FScriptDelegate";
  } else if (Category === "mcdelegate") {
    return "FMulticastScriptDelegate";
  } else {
    console.error(`Bad property type encountered: ${Category}`);
    return "BAD_VARIABLE_TYPE";
  }
}

/**
 * @return {string}
 */
function ObjectNameFromPath(ObjectPath) {
  if (!ObjectPath) return "";
  if (ObjectPath.endsWith("_C")) //Remove Class postfix
    ObjectPath = ObjectPath.substring(0, ObjectPath.length - 2);
  let SplitIndex = ObjectPath.indexOf(':');
  if (SplitIndex === -1)
    SplitIndex = ObjectPath.indexOf('.');
  return ObjectPath.substring(SplitIndex + 1);
}

/**
 * @return {string}
 */
function PropertyTypeToString(TypeObject) {
  let VariableType = GetBasicType(TypeObject.PinCategory, ObjectNameFromPath(TypeObject.PinSubCategoryObject), TypeObject.IsWeakPointer);
  let ContainerType = TypeObject.ContainerType;
  if (ContainerType == 1) {
    VariableType = `TArray<${VariableType}>`;
  } else if (ContainerType == 2) {
    VariableType = `TSet<${VariableType}>`;
  } else if (ContainerType == 3) {
    let ValueTypeObject = TypeObject.PinValueType;
    let ValueType = GetBasicType(ValueTypeObject.TerminalCategory, ObjectNameFromPath(ValueTypeObject.TerminalSubCategoryObject), ValueTypeObject.IsWeakPointer);
    if (ValueTypeObject.IsConst) {
      ValueType = `const ${ValueType}`;
    }
    VariableType = `TMap<${VariableType}, ${ValueType}>`;
  }
  if (TypeObject.IsReference) {
    VariableType = `${VariableType}&`;
  }
  if (TypeObject.IsConst) {
    VariableType = `const ${VariableType}`;
  }
  return VariableType;
}

/**
 * @return {boolean}
 */
//Rename fields which have autogenerated names
function ShouldRenameLocalVariable(VarName) {
  return VarName.startsWith("K2Node_") || VarName.startsWith("CallFunc_");
}

/**
 * @return {string}
 */
function GenerateLocalVariableName(VarType, UsedVariableNames) {
  VarType = PropertyTypeToString(VarType).replace("*", "").replace(RegExp("<>&"), "");
  let VariableName = `m${VarType}`;
  let VariableIndex = 1;
  while (UsedVariableNames[VariableName] !== undefined) {
    VariableName = `m${VarType}${VariableIndex++}`;
  }
  UsedVariableNames[VariableName] = true;
  return VariableName;
}

/**
 * @param Instruction {object}
 * @param FunctionState {object}
 * @param Context
 * @param IsAssignmentLeftSide
 * @return {string}
 */
function ToStringInstruction(Instruction, FunctionState, Context, IsAssignmentLeftSide = false) {
  let ResultExpression = _ToStringInstruction(Instruction, FunctionState, Context, IsAssignmentLeftSide);
  FunctionState.LastExpression = ResultExpression;
  return ResultExpression;
}

/**
 * @return {boolean}
 */
function IsLocalVariableInstruction(Instruction) {
  return Instruction === "EX_LocalVariable" || Instruction === "EX_LocalOutVariable";
}

/**
 * @param Instruction {object}
 * @param FunctionState {object}
 * @return {string}
 */
function _ToStringInstruction(Instruction, FunctionState, Context, IsAssignmentLeftSide) {
  if (IsLocalVariableInstruction(Instruction.Instruction)) {
    let VariableName = Instruction.VarName;
    let NewVariableName;
    if (FunctionState.RenamedLocalVariables[VariableName]) {
      NewVariableName = FunctionState.RenamedLocalVariables[VariableName];
    } else if (ShouldRenameLocalVariable(VariableName)) {
      NewVariableName = GenerateLocalVariableName(Instruction.VarType, FunctionState.UsedVariableNames);
      FunctionState.RenamedLocalVariables[VariableName] = NewVariableName;
    } else {
      NewVariableName = VariableName;
    }
    if (IsAssignmentLeftSide && !FunctionState.LocalVariables[VariableName]) {
      FunctionState.LocalVariables[VariableName] = true;
      return `${PropertyTypeToString(Instruction.VarType)} ${NewVariableName}`;
    }
    return NewVariableName;
  }
  if (Instruction.Instruction === "EX_InstanceVariable" || Instruction.Instruction === "EX_DefaultVariable") {
    let VariableName = Instruction.VarName;
    return Context + "->" + VariableName;
  }
  if (Instruction.Instruction === "EX_Return") {
    return "return";
  }
  if (Instruction.Instruction === "EX_Jump") {
    let JumpOffset = Instruction.Offset;
    return "goto L" + JumpOffset;
  }
  if (Instruction.Instruction === "EX_JumpIfNot") {
    let JumpOffset = Instruction.Offset;
    let OtherInstruction = ToStringInstruction(Instruction.Condition, FunctionState, FunctionState.Object);
    let FinalIfCondition = OtherInstruction.startsWith("!") ? OtherInstruction.substring(1) : ("!" + OtherInstruction);
    return "if (" + FinalIfCondition + ") goto L" + JumpOffset;
  }
  if (Instruction.Instruction === "EX_Assert") {
    let OtherInstruction = ToStringInstruction(Instruction.Condition, FunctionState, FunctionState.Object);
    return "assert(" + OtherInstruction + ")";
  }
  if (Instruction.Instruction === "EX_Nothing") {
    return "";
  }
  if (Instruction.Instruction === "EX_Let" ||
    Instruction.Instruction === "EX_LetBool" ||
    Instruction.Instruction === "EX_LetMulticastDelegate" ||
    Instruction.Instruction === "EX_LetDelegate" ||
    Instruction.Instruction === "EX_LetObj" ||
    Instruction.Instruction === "EX_LetWeakObjPtr") {
    let Property = Instruction.EvaluateProp;
    let PropertyInstruction = ToStringInstruction(Property, FunctionState, FunctionState.Object, true);
    let ValueInstruction = ToStringInstruction(Instruction.EvaluateExp, FunctionState, FunctionState.Object);
    return `${PropertyInstruction} = ${ValueInstruction}`
  }

  if (Instruction.Instruction === "EX_ClassContext") {
    let ContextInstruction = ToStringInstruction(Instruction.Context, FunctionState, Context);
    let ContextText = ContextInstruction + "->ClassDefaultObject";
    return ToStringInstruction(Instruction.Code, FunctionState, ContextText);
  }
  if (Instruction.Instruction === "EX_MetaCast") {
    let ClassInstruction = ToStringInstruction(Instruction.Castee, FunctionState, Context);
    let MetaClass = Instruction.MetaClass;
    return `ClassCast<${MetaClass}>(${ClassInstruction})`
  }
  if (Instruction.Instruction === "EX_Self") {
    return Context;
  }
  if (Instruction.Instruction === "EX_Context" || Instruction.Instruction === "EX_Context_FailSilent") {
    let ContextInstruction = ToStringInstruction(Instruction.Context, FunctionState, FunctionState.Object);
    return ToStringInstruction(Instruction.Code, FunctionState, ContextInstruction);
  }
  /**
   * @return {string}
   */
  function ToStringFunctionCall(CallPrefix) {
    let ResultArguments = [];
    for (let ArgumentInstruction of Instruction.Params) {
      let EvaluatedArgument = "";
      if (ArgumentInstruction.FunctionParamOut)
        EvaluatedArgument += "[ref] ";
      EvaluatedArgument += ToStringInstruction(ArgumentInstruction, FunctionState, FunctionState.Object);
      ResultArguments.push(EvaluatedArgument);
    }
    return CallPrefix + "(" + ResultArguments.join(", ") + ")";
  }
  if (Instruction.Instruction === "EX_VirtualFunction" || Instruction.Instruction === "EX_LocalVirtualFunction") {
    let FunctionName = ObjectNameFromPath(Instruction.Function);
    return ToStringFunctionCall(Context + "->" + FunctionName);
  }
  if (Instruction.Instruction === "EX_FinalFunction" || Instruction.Instruction === "EX_LocalFinalFunction") {
    let FunctionName = ObjectNameFromPath(Instruction.Function);
    return ToStringFunctionCall(Context + "->" + FunctionName);
  }
  if (Instruction.Instruction === "EX_CallMath") {
    let FunctionName = ObjectNameFromPath(Instruction.Function);
    return ToStringFunctionCall(FunctionName); //Math functions don't really need context
  }

  if (Instruction.Instruction === "EX_IntConst" ||
    Instruction.Instruction === "EX_FloatConst" ||
    Instruction.Instruction === "EX_ByteConst" ||
    Instruction.Instruction === "EX_IntConstByte" ||
    Instruction.Instruction === "EX_Int64Const" ||
    Instruction.Instruction === "EX_UInt64Const") {
    return Instruction.Value;
  }
  if (Instruction.Instruction === "EX_StringConst" ||
    Instruction.Instruction === "EX_NameConst" ||
    Instruction.Instruction === "EX_UnicodeStringConst") {
    return `"${Instruction.Value}"`;
  }
  if (Instruction.Instruction === "EX_ObjectConst") {
    let ObjectName = ObjectNameFromPath(Instruction.Value);
    if (ObjectName.startsWith("Default__"))
      ObjectName = ObjectName.substring("Default__".length);
    return ObjectName;
  }
  if (Instruction.Instruction === "EX_VectorConst") {
    return `Vector(${Instruction.X}, ${Instruction.Y}, ${Instruction.Z})`
  }
  if (Instruction.Instruction === "EX_RotationConst") {
    return `Rotator::FromPitchYawRoll(${Instruction.Pitch}, ${Instruction.Yaw}, ${Instruction.Roll})`;
  }
  if (Instruction.Instruction === "EX_IntOne") {
    return "1";
  }
  if (Instruction.Instruction === "EX_IntZero") {
    return "0";
  }
  if (Instruction.Instruction === "EX_True") {
    return "true";
  }
  if (Instruction.Instruction === "EX_False") {
    return "false";
  }
  if (Instruction.Instruction === "EX_TextConst") {
    let TextType = parseInt(Instruction.Type);
    if (TextType === 0) {
      return "";
    } else if (TextType === 1 || TextType === 2 || TextType == 3) {
      return `"${Instruction.SrcStr}"`;
    } else if (TextType === 4) {
      return `STRING_TABLE_ENTRY("${Instruction.StringTable}", "${Instruction.KeyStr}")`;
    }
  }
  if (Instruction.Instruction === "EX_NoObject" || Instruction.Instruction === "EX_NoInterface") {
    return "nullptr";
  }
  if (Instruction.Instruction === "EX_TransformConst") {
    let RotatorConst = `Rotator(${Instruction.RotX}, ${Instruction.RotY}, ${Instruction.RotZ}, ${Instruction.RotW})`;
    let TranslateConst = `Vector(${Instruction.TransX}, ${Instruction.TransY}, ${Instruction.TransZ})`;
    let ScaleConst = `Vector(${Instruction.ScaleX}, ${Instruction.ScaleY}, ${Instruction.ScaleZ})`;
    return `Transform(${RotatorConst}, ${TranslateConst}, ${ScaleConst})`;
  }
  if (Instruction.Instruction === "EX_DynamicCast") {
    let CastClass = Instruction.Type;
    let CastedExpression = ToStringInstruction(Instruction.Code, FunctionState, FunctionState.Object);
    return `Cast<${CastClass}>(${CastedExpression})`
  }
  if (Instruction.Instruction === "EX_StructConst") {
    let StructName = Instruction.Struct;
    let ArgumentArray = [];
    for (let Argument of Instruction.Value) {
      let ArgumentValue = ToStringInstruction(Argument, FunctionState, FunctionState.Object);
      ArgumentArray.push(`${Argument.StructPropName} = ${ArgumentValue}`);
    }
    return `${StructName}(${ArgumentArray.join(", ")})`;
  }
  /**
   * @return {string}
   */
  function CreateArrayLiteral() {
    let ArrayLiteralValues = [];
    for (let Argument of Instruction.Values) {
      let ArgumentValue = ToStringInstruction(Argument, FunctionState, FunctionState.Object);
      ArrayLiteralValues.push(ArgumentValue);
    }
    return `[${ArrayLiteralValues.join(", ")}]`;
  }
  /**
   * @return {string}
   */
  function CreateMapLiteral() {
    let MapLiteralValues = [];
    for (let Argument of Instruction.Values) {
      let KeyValue = ToStringInstruction(Argument.Key, FunctionState, FunctionState.Object);
      let ValueValue = ToStringInstruction(Argument.Value, FunctionState, FunctionState.Object);
      MapLiteralValues.push(`(${KeyValue} = ${ValueValue})`);
    }
    return `[${MapLiteralValues.join(", ")}]`;
  }
  if (Instruction.Instruction === "EX_SetArray") {
    let Array = Instruction.Array;
    let ArrayInstruction = ToStringInstruction(Array, FunctionState, FunctionState.Object, true);
    let ArrayLiteral = CreateArrayLiteral();
    if (IsLocalVariableInstruction(Array.Instruction)) {
    }
    return `${ArrayInstruction} = ${ArrayLiteral}`;
  }
  if (Instruction.Instruction === "EX_ArrayConst") {
    let ArrayType = Instruction.Type;
    let ArrayLiteral = CreateArrayLiteral();
    return `${ArrayType}[] {${ArrayLiteral}}`;
  }
  if (Instruction.Instruction === "EX_SetSet") {
    let Set = Instruction.Set;
    let SetInstruction = ToStringInstruction(Set, FunctionState, FunctionState.Object, true);
    let ArrayLiteral = CreateArrayLiteral();
    if (IsLocalVariableInstruction(Set.Instruction)) {
    }
    return `${SetInstruction} = ${ArrayLiteral}`;
  }
  if (Instruction.Instruction === "EX_SetConst") {
    let SetType = Instruction.Type;
    let ArrayLiteral = CreateArrayLiteral();
    return `Set<${SetType}>(${ArrayLiteral})`;
  }
  if (Instruction.Instruction === "EX_SetMap") {
    let Map = Instruction.Map;
    let MapInstruction = ToStringInstruction(Map, FunctionState, FunctionState.Object, true);
    let MapLiteral = CreateMapLiteral();
    return `${MapInstruction} = ${MapLiteral}`;
  }
  if (Instruction.Instruction === "EX_MapConst") {
    let MapType = `Map<${Instruction.KeyType}, ${Instruction.ValueType}>`;
    let MapLiteral = CreateMapLiteral();
    return `${MapType}(${MapLiteral})`;
  }
  if (Instruction.Instruction === "EX_StructMemberContext") {
    let StructValue = ToStringInstruction(Instruction.Code, FunctionState, FunctionState.Object);
    let PropertyName = Instruction.Context;
    return `${StructValue}.${PropertyName}`;
  }
  if (Instruction.Instruction === "EX_PushExecutionFlow") {
    let JumpOffset = Instruction.Offset;
    return `ExecutionFlow.Push(L${JumpOffset})`;
  }
  if (Instruction.Instruction === "EX_PopExecutionFlow") {
    return `goto ExecutionFlow.Pop()`;
  }
  if (Instruction.Instruction === "EX_PopExecutionFlowIfNot") {
    let OtherInstruction = ToStringInstruction(Instruction.Condition, FunctionState, FunctionState.Object);
    let FinalIfCondition = OtherInstruction.startsWith("!") ? OtherInstruction.substring(1) : ("!" + OtherInstruction);
    return "if (" + FinalIfCondition + ") goto ExecutionFlow.Pop()";
  }
  if (Instruction.Instruction === "EX_ComputedJump") {
    let JumpTarget = ToStringInstruction(Instruction.Offset, FunctionState, FunctionState.Object);
    return `goto ComputedJump(${JumpTarget})`
  }
  if (Instruction.Instruction === "EX_PrimitiveCast") {
    let CastedValue = ToStringInstruction(Instruction.Value, FunctionState, FunctionState.Object);
    let CastIndex = parseInt(Instruction.Cast);
    if (CastIndex == 70) Instruction.Instruction = "EX_ObjToInterfaceCast";
    else return CastedValue;
  }
  if (Instruction.Instruction === "EX_InterfaceContext") {
    let InterfaceObject = ToStringInstruction(Instruction.Interface, FunctionState, Context);
    return `GetInterfaceUObject(${InterfaceObject})`;
  }
  if (Instruction.Instruction === "EX_ObjToInterfaceCast") {
    let ObjectValue = ToStringInstruction(Instruction.Value, FunctionState, FunctionState.Object);
    let InterfaceType = Instruction.Type;
    return `QueryInterface<${InterfaceType}>(${ObjectValue})`;
  }
  if (Instruction.Instruction === "EX_CrossInterfaceCast") {
    let InterfaceValue = ToStringInstruction(Instruction.Value, FunctionState, FunctionState.Object);
    let InterfaceType = Instruction.Type;
    return `InterfaceCast<${InterfaceType}>(${InterfaceValue})`;
  }
  if (Instruction.Instruction === "EX_InterfaceToObjCast") {
    let InterfaceValue = ToStringInstruction(Instruction.Value, FunctionState, FunctionState.Object);
    let ObjectType = Instruction.Type;
    return `Cast<${ObjectType}>(GetInterfaceUObject(${InterfaceValue})`;
  }
  if (Instruction.Instruction === "EX_SkipOffsetConst") {
    return Instruction.Value;
  }
  if (Instruction.Instruction === "EX_AddMulticastDelegate") {
    let VariableObject = ToStringInstruction(Instruction.Variable, FunctionState, FunctionState.Object);
    let BoundObject = ToStringInstruction(Instruction.Delegate, FunctionState, FunctionState.Object);
    return `${VariableObject}.AddUnique(${BoundObject})`;
  }
  if (Instruction.Instruction === "EX_RemoveMulticastDelegate") {
    let VariableObject = ToStringInstruction(Instruction.Variable, FunctionState, FunctionState.Object);
    let BoundObject = ToStringInstruction(Instruction.Delegate, FunctionState, FunctionState.Object);
    return `${VariableObject}.Remove(${BoundObject})`;
  }
  if (Instruction.Instruction === "EX_ClearMulticastDelegate") {
    let VariableObject = ToStringInstruction(Instruction.Variable || Instruction.Delegate, FunctionState, FunctionState.Object);
    return `${VariableObject}->Clear()`;
  }
  if (Instruction.Instruction === "EX_InstanceDelegate") {
    let DelegateFunctionName = Instruction.FunctionName;
    return `${FunctionState.LastExpression}->BindUFunction(${FunctionState.Object}, ${DelegateFunctionName})`;
  }
  if (Instruction.Instruction === "EX_BindDelegate") {
    let VariableObject = ToStringInstruction(Instruction.Variable, FunctionState, FunctionState.Object);
    let DelegateFunctionName = Instruction.FunctionName;
    let BoundObject = ToStringInstruction(Instruction.Object, FunctionState, FunctionState.Object);
    return `${VariableObject}->BindUFunction(${BoundObject}, ${DelegateFunctionName})`;
  }
  if (Instruction.Instruction === "EX_CallMulticastDelegate") {
    let VariableObject = ToStringInstruction(Instruction.Variable, FunctionState, FunctionState.Object);
    return ToStringFunctionCall(`${VariableObject}->ProcessMulticastDelegate`);
  }
  if (Instruction.Instruction === "EX_LetValueOnPersistentFrame") {
    let ValueInstruction = ToStringInstruction(Instruction.Value, FunctionState, FunctionState.Object);
    let PropertyName = Instruction.Dest;
    return `PERSISTENT_FRAME(${PropertyName}) = ${ValueInstruction}`;
  }
  if (Instruction.Instruction === "EX_SoftObjectConst") {
    let Value = ToStringInstruction(Instruction.Value, FunctionState, FunctionState.Object);
    return `SoftObjectPath(${Value})`;
  }
  if (Instruction.Instruction === "EX_ArrayGetByRef") {
    let ArrayVariable = ToStringInstruction(Instruction.Variable, FunctionState, FunctionState.Object);
    let ElementIndex = ToStringInstruction(Instruction.Index, FunctionState, FunctionState.Object);
    return `${ArrayVariable}[${ElementIndex}]`;
  }
  if (Instruction.Instruction === "EX_SwitchValue") {
    let InputValue = ToStringInstruction(Instruction.Input, FunctionState, FunctionState.Object);
    let DefaultValue = ToStringInstruction(Instruction.Default, FunctionState, FunctionState.Object);
    let ResultValue = `switch (${InputValue}) {\n`;
    for (let CaseObject of Instruction.Cases) {
      let MatchValue = ToStringInstruction(CaseObject.Match, FunctionState, FunctionState.Object);
      let MatchResultValue = ToStringInstruction(CaseObject.Result, FunctionState, FunctionState.Object);
      ResultValue += `case ${MatchValue} -> ${MatchResultValue};\n`;
    }
    ResultValue += `default -> ${DefaultValue};\n`;
    ResultValue += "}";
    return ResultValue;
  }
  if (Instruction.Instruction === "EX_EndOfScript") {
    return "";
  }
  if (Instruction.Instruction === "End") {
    return "<End of Inlined Event Graph Function>";
  }
  console.error(`Encountered unknown instruction: ${Instruction.Instruction}`);
  return "UNKNOWN_INSTRUCTION";
}

function EnsureDirectoryExists(DirectoryPath) {
  if (!fs.existsSync(DirectoryPath)) {
    let ParentPath = path.dirname(DirectoryPath);
    EnsureDirectoryExists(ParentPath);
    fs.mkdirSync(DirectoryPath);
  }
}

function AppendFunctionCode(FunctionName, CodeArray, Appender) {
  Appender("============ BEGIN FUNCTION " + FunctionName + " ==============\n");
  let FunctionState = {LocalVariables: {}, RenamedLocalVariables: {}, UsedVariableNames: {}, Object: "this", LastExpression: "$INVALID_EXPRESSION$" };
  for (let CodeElement of CodeArray) {
    let InstructionOffset = CodeElement.InstOffsetFromTop;
    let LinePrefix = (`L${InstructionOffset}:`).padEnd(15, ' ');
    let InstructionText = ToStringInstruction(CodeElement, FunctionState, FunctionState.Object);
    Appender(`${LinePrefix}${InstructionText};\n`);
  }
  Appender("============ END FUNCTION " + FunctionName + " ==============\n");
}

for (let Blueprint of ParsedJson.Blueprints) {
  let BlueprintName = Blueprint.Blueprint;
  let BlueprintFunctions = Blueprint.Functions;
  if (BlueprintFunctions) {
    let ResultFileContents = "";
    ResultFileContents += "########################'\n";
    ResultFileContents += "FUNCTION CODE DUMP OF: " + BlueprintName + "\n";
    ResultFileContents += "########################\n";
    let ShouldWriteFile = false;
    console.log(`Analyzing blueprint class ${BlueprintName}`);

    for (let FunctionObject of BlueprintFunctions) {
      let FunctionName = FunctionObject.Name;
      if (FunctionObject.Code) {
        ShouldWriteFile = true;
        console.log(`Parsing function ${FunctionName}`);
        ResultFileContents += "\n".repeat(5);
        AppendFunctionCode(FunctionName, FunctionObject.Code, (arg) => { ResultFileContents += arg; })
      }
    }

    if (ShouldWriteFile) {
      let ResultFilePath = "Outputs" + BlueprintName + ".txt";
      EnsureDirectoryExists(path.dirname(ResultFilePath));
      fs.writeFileSync(ResultFilePath, ResultFileContents, "utf8");
    }
  }
}

